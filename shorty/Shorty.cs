using System;
using System.CodeDom;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.Contracts;
using System.IO;
using System.Linq;
using System.Management.Instrumentation;
using System.Net.Configuration;
using System.Reflection.Emit;
using Microsoft.Dafny;
using Bpl = Microsoft.Boogie;

namespace shorty
{
    internal class Shorty
    {
        //Asserts
        public readonly Dictionary<Statement, List<AssertStmt>> asserts = new Dictionary<Statement, List<AssertStmt>>();
        public readonly Dictionary<Statement, List<AssertStmt>> andAsserts = new Dictionary<Statement, List<AssertStmt>>();


        public readonly Dictionary<Method, List<Tuple<AssertStmt, Statement>>> assertsParents = new Dictionary<Method, List<Tuple<AssertStmt, Statement>>>();
        //Dictionary<Method, Dictionary<AssertStmt, Statement>>;

        List<AssertStmt> assertsToKeep = new List<AssertStmt>();
        private Program program;

        private List<BlockStmt> ErrorBlocks = new List<BlockStmt>(); //Blocks with errors in them
        List<MatchCaseStmt> errorMatches = new List<MatchCaseStmt>();
        Dictionary<AssertStmt, Statement> removedParentsDictionary = new Dictionary<AssertStmt, Statement>();
        Dictionary<AssertStmt, MatchCaseStmt> removedCaseStmts = new Dictionary<AssertStmt, MatchCaseStmt>();

        // Modes:
        // All removes all asserts at once and then tries to reinsert them based on the error message - it does not always 100% succesed
        // Singular removes asserts once at a time - it takes longer but is more robust.
        public enum Mode
        {
            All,
            Singular
        }

        private Mode mode;

        //Invariants
        public readonly Dictionary<LoopStmt, List<MaybeFreeExpression>> invariants = new Dictionary<LoopStmt, List<MaybeFreeExpression>>();

        //Decreases
        public readonly Dictionary<Method, List<LoopStmt>> decreases = new Dictionary<Method, List<LoopStmt>>();

        //Lemma Calls
        public readonly Dictionary<Statement, List<UpdateStmt>> lemmaCalls = new Dictionary<Statement, List<UpdateStmt>>(); //The type of lemma calls we want to remove are inside UpdateStatement

        #region Initialisation

        public Shorty(Program program, Mode mode)
        {
            Contract.Requires(program != null);
            this.mode = mode;
            this.program = program;
            FindRemovables();
        }

        public void PrintAsserts()
        {
            Console.WriteLine();
            int i = 0, j = 0;

            foreach (var block in asserts.Keys) {
                Console.WriteLine("Block " + ++i + ", Line " + block.Tok.line);
                foreach (var assert in asserts[block]) {
                    Console.WriteLine(++j + ": " + assert.Tok.line);
                }
            }
        }

        #endregion

        #region Utility

        public void PrintProgram(TextWriter writer)
        {
            //First off all of the auto-generated decreases need to be removed

            Dictionary<AutoGeneratedExpression, Tuple<List<Expression>, int>> removedExpresseions = new Dictionary<AutoGeneratedExpression, Tuple<List<Expression>, int>>();

            foreach (Method method in decreases.Keys) {
                //first off, remove the decreases from the method.

                for (int i = method.Decreases.Expressions.Count - 1; i >= 0; i--) {
                    Expression expr = method.Decreases.Expressions[i];
                    if (!(expr is AutoGeneratedExpression)) continue;
                    method.Decreases.Expressions.Remove(expr);
                    Tuple<List<Expression>, int> insertionPlace = new Tuple<List<Expression>, int>(method.Decreases.Expressions, i);
                    removedExpresseions.Add((AutoGeneratedExpression) expr, insertionPlace);
                }
                foreach (LoopStmt loopStmt in decreases[method]) {
                    var expressions = loopStmt.Decreases.Expressions;
                    for (int i = loopStmt.Decreases.Expressions.Count - 1; i >= 0; i--) {
                        Expression expr = loopStmt.Decreases.Expressions[i];
                        if (!(expr is AutoGeneratedExpression)) continue;
                        loopStmt.Decreases.Expressions.Remove(expr);
                        Tuple<List<Expression>, int> insertionPlace = new Tuple<List<Expression>, int>(loopStmt.Decreases.Expressions, i);
                        removedExpresseions.Add((AutoGeneratedExpression) expr, insertionPlace);
                    }
                }
            }


            Microsoft.Dafny.Printer dafnyPrinter = new Printer(writer);
            dafnyPrinter.PrintProgram(program);


            //now we have to reinsert all of the expressions
            foreach (AutoGeneratedExpression expr in removedExpresseions.Keys) {
                int spot = removedExpresseions[expr].Item2;
                List<Expression> list = removedExpresseions[expr].Item1;
                if (spot < list.Count) {
                    list.Insert(spot, expr);
                }
                else {
                    list.Add(expr);
                }
            }
        }

        #endregion

        #region tree traversal

        private void FindRemovables()
        {
            //foreach (var module in program.Modules) {
                //look through each module...
                foreach (var decl in program.DefaultModuleDef.TopLevelDecls) {
                    //lookthrough all TopDeclaration...
                    if (decl is ClassDecl) {
                        //we need to look through classes to find members which might contain allAsserts
                        var classDecl = (ClassDecl) decl;
                        foreach (var member in classDecl.Members) {
                            CheckMember(member);
                        }
                    }
                }
            //}
        }

        private void CheckMember(MemberDecl member)
        {
            Contract.Requires(member != null);
            if (member is Method) {
                //If the member is a method it has a body which can contian statements
                var method = (Method) member;
                GetDecreasesMethod(method);
                var block = method.Body;
                if (block != null) {
                    foreach (var statement in block.Body) {
                        //We can now see all the statements in the blocks body.
                        CheckStatement(statement, block, method);
                    }
                }
            }
//            else
//            { Console.WriteLine("Member not method"); }
        }

        private void CheckStatement(Statement statement, Statement parent, Method method)
        {
            Contract.Requires(statement != null);
            Contract.Requires(parent != null);
            if (statement is AssertStmt) {
                //If the parent is in the dictionary, add the assert to the parent.  Otherwise, add it aswell as the item in a new list.
                AssertStmt assert = (AssertStmt) statement;
                
                if (!assertsParents.ContainsKey(method)) {
                    assertsParents.Add(method, new List<Tuple<AssertStmt, Statement>>());
                }
                assertsParents[method].Add(new Tuple<AssertStmt, Statement>(assert, parent));
                if (asserts.ContainsKey(parent)) {
                    if (!asserts[parent].Contains(statement)) {
                        asserts[parent].Add((AssertStmt) statement);
                    }
                }
                else {
                    asserts.Add(parent, new List<AssertStmt> {(AssertStmt) statement});
                }

                //If the assert is an AND operator, add it to the andAsserts
                if (assert.Expr is BinaryExpr) {
                    var binExpr = (BinaryExpr) assert.Expr;
                    if (binExpr.Op == BinaryExpr.Opcode.And) {
                        if (!andAsserts.ContainsKey(parent)) {
                            andAsserts.Add(parent, new List<AssertStmt>());
                        }

                        andAsserts[parent].Add(assert);
                    }
                }
            }
            else if (statement is BlockStmt) {
                BlockStmt blockStmt = (BlockStmt) statement;
                foreach (var stmt in blockStmt.Body) {
                    CheckStatement(stmt, statement, method);
                }
            }
            else if (statement is IfStmt) {
                IfStmt ifstmt = (IfStmt) statement;
                CheckStatement(ifstmt.Thn, statement, method);
                CheckStatement(ifstmt.Els, statement, method);
            }
            else if (statement is LoopStmt) {
                LoopStmt loopStmt = (LoopStmt) statement;
                GetLoopInvariants(loopStmt);
                GetDecreasesLoop(loopStmt, method);
                if (loopStmt is WhileStmt) {
                    WhileStmt whileStmt = (WhileStmt) loopStmt;
                    CheckStatement(whileStmt.Body, statement, method);
                }
            }
            else if (statement is MatchStmt) {
                MatchStmt match = (MatchStmt) statement;
                foreach (MatchCaseStmt matchCase in match.Cases) {
                    foreach (Statement stmt in matchCase.Body) {
                        CheckStatement(stmt, statement, method);
                    }
                }
            }
            else if (statement is ForallStmt) {
                ForallStmt forall = (ForallStmt) statement;
                CheckStatement(forall.Body, statement, method);
            }
            else if (statement is CalcStmt) {
                CalcStmt calc = (CalcStmt) statement;
                foreach (var hint in calc.Hints) {
                    CheckStatement(hint, statement, method);
                }
            }
            else if (statement is UpdateStmt) {
                UpdateStmt updateStmt = (UpdateStmt) statement;
                foreach (var stmt in updateStmt.ResolvedStatements) {
                    if (stmt is CallStmt) {
                        CallStmt callStmt = (CallStmt) stmt;
                        if (callStmt.Method.IsGhost) //Should find lemmas and ghost methods
                        {
                            if (!lemmaCalls.ContainsKey(parent)) {
                                lemmaCalls.Add(parent, new List<UpdateStmt>());
                            }
                            lemmaCalls[parent].Add(updateStmt);
                        }
                    }
                }
            }
            else {
                //Console.WriteLine("Unrecognised statement on line " + statement.Tok.line);
            }
        }

        #endregion

        #region Lemma Calls

        public List<UpdateStmt> FindRemovableLemmaCalls()
        {
            List<UpdateStmt> removableLemmaCalls = new List<UpdateStmt>();

            foreach (Statement stmt in lemmaCalls.Keys) {
                if (stmt is BlockStmt) {
                    BlockStmt block = (BlockStmt) stmt;
                    for (int i = lemmaCalls[block].Count - 1; i >= 0; i--) {
                        UpdateStmt lemmaCall = lemmaCalls[block][i];
                        block.Body.Remove(lemmaCall);
                        if (!IsProgramValid()) {
                            //for some reason this passes when it shouldnt
                            block.Body.Insert(i, lemmaCall);
                        }
                        else {
                            removableLemmaCalls.Add(lemmaCall);
                        }
                    }
                }
                else if (stmt is MatchStmt) {}
            }

            return removableLemmaCalls;
        }

        #endregion

        #region decreases

        void GetDecreasesLoop(LoopStmt loop, Method method)
        {
            if (loop.Decreases.Expressions.Count > 0) {
                if (!decreases.ContainsKey(method)) {
                    decreases.Add(method, new List<LoopStmt>());
                }
                decreases[method].Add(loop);
            }
        }

        /// <summary>
        /// this is needed because methods can have decreases statements, and will almost always have an auto generated one inserted
        /// </summary>
        /// <param name="method"></param>
        void GetDecreasesMethod(Method method)
        {
            if (!decreases.ContainsKey(method) && method.Decreases.Expressions.Count > 0) {
                decreases.Add(method, new List<LoopStmt>());
            }
//            else {Console.WriteLine("sdfgsdgf"); }
        }

        public List<Expression> FindRemoveableDecreases()
        {
            List<Expression> removeableDecreases = new List<Expression>();

            foreach (Method method in decreases.Keys) {
                //first off, remove the decreases from the method.
                for (int i = method.Decreases.Expressions.Count - 1; i >= 0; i--) {
                    Expression expr = method.Decreases.Expressions[i];
                    if (expr == null || expr is AutoGeneratedExpression) continue;
                    method.Decreases.Expressions.Remove(expr);
                    //Insert an auto-generated one or see if there is one that can be inserted or something...

//                    try {
//                        Resolver r = new Resolver(program);
//                        r.ResolveProgram(program);
//                        Console.WriteLine("succeeded");
//                    }
//                    catch {
//                        Console.WriteLine("failed");   
//                    }

                    if (!IsProgramValid()) {
                        Console.WriteLine("\nCannot remove decreases at " + expr.tok.line + "\n");
                        method.Decreases.Expressions.Insert(i, expr);
                        //TODO: remove auto generated one?  can there even be one?
                    }
                    else {
                        removeableDecreases.Add(expr);
                    }
                }

                foreach (LoopStmt loop in decreases[method]) {
                    for (int i = loop.Decreases.Expressions.Count - 1; i >= 0; i--) {
                        Expression expr = loop.Decreases.Expressions[i];
                        if (expr == null || expr is AutoGeneratedExpression) continue;
                        loop.Decreases.Expressions.Remove(expr);
                        //Insert an auto-generated one or see if there is one that can be inserted or something...
                        if (!IsProgramValid()) {
                            Console.WriteLine("\nCannot remove decreases at " + expr.tok.line + "\n");
                            loop.Decreases.Expressions.Insert(i, expr);
                            //TODO: remove auto generated one?  can there even be one?
                        }
                        else {
                            removeableDecreases.Add(expr);
                        }
                    }
                }
            }

            return removeableDecreases;
        }

        /// <summary>
        /// This removes all auto generated decreases expressions as otherwise they will get
        /// reinserted when printing the program.
        /// </summary>
        public void RemoveAutoGeneratedDecreases()
        {
            foreach (Method method in decreases.Keys) {
                foreach (LoopStmt loopStmt in decreases[method]) {
                    var expressions = loopStmt.Decreases.Expressions;
                    for (int i = loopStmt.Decreases.Expressions.Count - 1; i >= 0; i--) {
                        if (expressions[i] is AutoGeneratedExpression) {
                            expressions.RemoveAt(i);
                        }
                    }
                }
                for (int i = method.Decreases.Expressions.Count - 1; i >= 0; i--) {
                    if (method.Decreases.Expressions[i] is AutoGeneratedExpression) {
                        method.Decreases.Expressions.RemoveAt(i);
                    }
                }
            }
        }

        #endregion

        #region Invariants

        void GetLoopInvariants(LoopStmt loop)
        {
            if (!invariants.ContainsKey(loop))
                invariants.Add(loop, loop.Invariants);
        }

        public List<MaybeFreeExpression> FindRemovableInvariants()
        {
            //should maybe do something like creating a copy of the ast because it is being changed.
            List<MaybeFreeExpression> removeableInvariants = new List<MaybeFreeExpression>();

            foreach (var loopStmt in invariants.Keys) {
                List<MaybeFreeExpression> invariantList = invariants[loopStmt];
                //invariantList.Reverse(); //flip order to work from bottom up.

                for (int i = invariantList.Count - 1; i >= 0; i--) {
                    if (invariantList[i] == null)
                        continue;
                    MaybeFreeExpression invariant = invariantList[i];
                    invariantList.Remove(invariant);
                    Console.WriteLine("Removing at line {0}", invariant.E.tok.line);
                    if (!IsProgramValid()) {
                        Console.WriteLine("Failed at line {0}", invariant.E.tok.line);
                        invariantList.Insert(i, invariant);
                    }
                    else {
                        removeableInvariants.Add(invariant);
                        Console.WriteLine("Succeeded at line {0}", invariant.E.tok.line);
                    }
                }
            }
            return removeableInvariants;
        }

        #endregion

        #region Asserts

        public Dictionary<Method, List<List<AssertStmt>>> TestDifferentRemovals()
        {
            Dictionary<Method, List<List<AssertStmt>>> returnData = new Dictionary<Method, List<List<AssertStmt>>>();

   
            foreach (Method method in assertsParents.Keys) {
                List<List<AssertStmt>> solutions = new List<List<AssertStmt>>();
                TestRemovals(0, true, solutions, new List<AssertStmt>(), method);
                returnData.Add(method, solutions);
            }
            return returnData;
        }

        private void TestRemovals(int index, bool first, List<List<AssertStmt>> solutions, List<AssertStmt> currentSolution, Method method)
        {
            if (index == assertsParents[method].Count) {
                solutions.Add(new List<AssertStmt>(currentSolution));
                return;
            }

            var parent = assertsParents[method][index].Item2;
            var assert = assertsParents[method][index].Item1;

            if (parent is BlockStmt) {
                var block = (BlockStmt) parent;
                int assertPos = block.Body.IndexOf(assert);
                block.Body.Remove(assert);
                if (IsProgramValid()) {
                    var newCurrentSolution = new List<AssertStmt>(currentSolution) {assert}; //create a copy of the currentSolution and add in the assert
                    TestRemovals(index+1, first, solutions, newCurrentSolution, method);
                    block.Body.Insert(assertPos, assert);
                    TestRemovals(index+1, false, solutions, currentSolution, method);
                }
                else {
                    block.Body.Insert(assertPos, assert);
                    TestRemovals(index + 1, first, solutions, currentSolution, method);
                }

            }
            else if (parent is MatchStmt) {
                var matchStmt = (MatchStmt) parent;
                bool found = false;
                foreach (var matchCase in matchStmt.Cases) {
                    if (matchCase.Body.Contains(assert)) {
                        found = true;
                        int assertPos = matchCase.Body.IndexOf(assert);
                        matchCase.Body.Remove(assert);
                        if (IsProgramValid())
                        {
                            var newCurrentSolution = new List<AssertStmt>(currentSolution) { assert }; //create a copy of the currentSolution and add in the assert
                            TestRemovals(index + 1, first, solutions, newCurrentSolution, method);
                            matchCase.Body.Insert(assertPos, assert);
                            TestRemovals(index + 1, false, solutions, currentSolution, method);
                        }
                        else
                        {
                            matchCase.Body.Insert(assertPos, assert);
                            TestRemovals(index + 1, first, solutions, currentSolution, method);
                        }
                    }
                }
                if (!found) {
                    throw new Exception("assert not found in match case");
                }

            }
        }

        public List<Tuple<AssertStmt, AssertStmt>> GetSimplifiedAsserts()
        {
            var simplifiedAsserts = new List<Tuple<AssertStmt, AssertStmt>>();

            foreach (Statement stmnt in andAsserts.Keys) {
                if (!(stmnt is BlockStmt)) continue;
                var bl = (BlockStmt) stmnt;
                foreach (AssertStmt assert in asserts[stmnt]) {
                    int index = bl.Body.IndexOf(assert);
                    bl.Body.Remove(assert);
                    if (!IsProgramValid()) {
                        //Break down the asserts
                        var brokenAsserts = BreakDownExpr(assert);
                        //Add them back in
                        foreach (var brokenAssert in brokenAsserts) {
                            bl.Body.Insert(index, brokenAssert);                                
                        }
                        brokenAsserts.Reverse();
                        //Test to see which can be removed
                        for (int i = brokenAsserts.Count-1; i >= 0; i--) {
                            int j = bl.Body.IndexOf(brokenAsserts[i]);
                            bl.Body.Remove(brokenAsserts[i]);
                            if (IsProgramValid()) {
                                brokenAsserts.Remove(brokenAsserts[i]); //Item was removed successfully
                            }
                            else {
                                bl.Body.Insert(j, brokenAsserts[i]); //Item could not be removed - reinsert
                            }
                        }
                        simplifiedAsserts.Add(new Tuple<AssertStmt, AssertStmt>(assert, CombineAsserts(brokenAsserts)));
                    }
                    else {
                        Console.WriteLine("Item can be completely removed separately");
                    }
                }
            }

            return simplifiedAsserts;
        }

        private AssertStmt CombineAsserts(List<AssertStmt> brokenAsserts)
        {
            if (brokenAsserts.Count < 1)
            {
                return null;
            }
            if (brokenAsserts.Count == 1)
                return brokenAsserts[0];

            var assert = brokenAsserts[0];
            brokenAsserts.Remove(assert);
            //Need to do combine attributes somehow?
            Expression left = brokenAsserts[0].Expr;
            Expression right = CombineAsserts(brokenAsserts).Expr;
            BinaryExpr binExpr = new BinaryExpr(left.tok, BinaryExpr.Opcode.And, left, right);
            AssertStmt newAssert = new AssertStmt(assert.Tok, assert.EndTok, binExpr, assert.Attributes);
            return newAssert;
        }

        /// <summary>
        /// Breaks down an assert statement based off of && operators
        /// </summary>
        /// <param name="assert">The statement to break down</param>
        /// <returns>a list of new assert statements that can be separateley tested</returns>
        private List<AssertStmt> BreakDownExpr(AssertStmt assert)
        {
            var brokenAsserts = new List<AssertStmt>();
            if (assert.Expr is BinaryExpr) {
                BinaryExpr expr = (BinaryExpr)assert.Expr;
                if (expr.Op == BinaryExpr.Opcode.And) {//or or statements or anything else???
                    AssertStmt newAssert = new AssertStmt(expr.tok, assert.EndTok, expr.E0, assert.Attributes);
                    AssertStmt newAssert2 = new AssertStmt(expr.tok, assert.EndTok, expr.E1, assert.Attributes);

                    brokenAsserts.AddRange(BreakDownExpr(newAssert));
                    brokenAsserts.AddRange(BreakDownExpr(newAssert2));
                    return brokenAsserts;
                }
            }
            brokenAsserts.Add(assert);
            return brokenAsserts;
        }

        private void TryToRemoveAssert(AssertStmt assert, BlockStmt block, Dictionary<AssertStmt, Statement> removedParentsDictionary, List<AssertStmt> removedCaseAsserts)
        {
            if (!assertsToKeep.Contains(assert)) {
                int index = block.Body.IndexOf(assert);
                block.Body.Remove(assert);
                //all at once method
                if (mode == Mode.All) {
                    if (!removedParentsDictionary.ContainsKey(assert) && !removedCaseAsserts.Contains(assert)) {
                        removedParentsDictionary.Add(assert, block);
                    }
                }
                //as it goes method
                else if (mode == Mode.Singular) {
                    if (!IsProgramValid()) {
                        block.Body.Insert(index, assert);
                    }
                    else if (!removedParentsDictionary.ContainsKey(assert)) {
                        removedParentsDictionary.Add(assert, block);
                    }
                }
            }
        }

        public List<AssertStmt> FindUnnecessaryAsserts()
        {
            if (!IsProgramValid()) {
                Console.WriteLine("Program " + program.FullName + " cannot verify -> cannot remove asserts until it is fixed");
                return null;
            }

            //go through each block
            foreach (Statement stmnt in asserts.Keys) {
                if (stmnt is BlockStmt) {
                    BlockStmt bl = (BlockStmt) stmnt;
                    foreach (AssertStmt assert in asserts[stmnt]) {
                        TryToRemoveAssert(assert, bl, removedParentsDictionary, removedCaseStmts.Keys.ToList());
                    }
                }
                // Match statements are not stored in a block or inherited from notmal statements so we need a special case from them
                else if (stmnt is MatchStmt) {
                    MatchStmt ms = (MatchStmt) stmnt;
                    foreach (AssertStmt assert in asserts[stmnt]) {
                        foreach (MatchCaseStmt mcs in ms.Cases) {
                            if (!assertsToKeep.Contains(assert)) {
                                mcs.Body.Remove(assert);
                                if (mode == Mode.All) {
                                    if (!removedCaseStmts.ContainsKey(assert) && !removedParentsDictionary.ContainsKey(assert))
                                        removedCaseStmts.Add(assert, mcs);
                                }
                                else if (mode == Mode.Singular) {
                                    if (!IsProgramValid()) {
                                        mcs.Body.Add(assert);
                                    }
                                    else {
                                        if (!removedCaseStmts.ContainsKey(assert))
                                            removedCaseStmts.Add(assert, mcs);
                                    }
                                }
                            }
                        }
                    }
                }
            }
            if (mode == Mode.All) {
                //See if the program is valid
                if (!IsProgramValid()) {
                    Console.WriteLine("\n\nTrying again\n\n");
                    //Try again to see if it has fixed itself
                    if (IsProgramValid()) {
                        if (ErrorBlocks.Count != 0) {
                            foreach (BlockStmt block in ErrorBlocks) {
                                foreach (var assert in asserts[block]) {
                                    block.Body.Remove(assert);
                                    if (!IsProgramValid()) {
                                        block.Body.Add(assert);
                                    }
                                }
                            }
                            //Clear out the old blocks
                            ErrorBlocks = new List<BlockStmt>();
                        }
                        Console.WriteLine("All asserts were removable");
                    }
                    else {
                        Console.WriteLine("Not fixed");
                    }
                }
                else {}
            }
            return removedParentsDictionary.Keys.Concat(removedCaseStmts.Keys).ToList();
        }

        #endregion

        #region validation

        public void BoogieErrorInformation(Bpl.ErrorInformation errorInfo)
        {
            if (mode == Mode.All) {
                // This is not working
                Console.WriteLine("Error: " + errorInfo.Tok.line + ", " + errorInfo.Tok.col);
                Bpl.IToken token = errorInfo.Tok;

                Statement maxBlock = asserts.Keys.ToList()[0];
                foreach (Statement block in asserts.Keys) {
                    if (block.Tok.line <= token.line && block.EndTok.line >= token.line && block.Tok.line > maxBlock.Tok.line) {
                        maxBlock = block;
                    }
                }

                List<Statement> allStatements = new List<Statement>();

                //Find nested blocks
                foreach (Statement block in asserts.Keys) {
                    if (block.Tok.line >= maxBlock.Tok.line && block.EndTok.line <= maxBlock.EndTok.line) {
                        allStatements.Add(block);
                        Console.WriteLine("Found nested block");
                    }
                }

                Console.WriteLine("Found token " + token.line + "in Block at " + maxBlock.Tok.line);
                foreach (Statement statement in allStatements) {
                    if (statement is BlockStmt) {
                        BlockStmt blockStmt = (BlockStmt) statement;
                        ErrorBlocks.Add(blockStmt);
                        //Add all the asserts from this block back in
                        foreach (var assert in asserts[statement]) {
                            if (removedParentsDictionary.ContainsKey(assert)) {
//                                for ( int i = 0; i <= blockStmt.Body.Count; i++) {
//                                    if (blockStmt.Body[i] != null) {
//                                        if (blockStmt.Body[i].Tok.pos > assert.Tok.pos) {
//                                            blockStmt.Body.Insert(i, assert);
//                                        }
//                                    }
//                                }
                                foreach (Statement stmt in blockStmt.Body) {
                                    if (stmt.Tok.pos > assert.Tok.pos) {
                                        blockStmt.Body.Insert(blockStmt.Body.IndexOf(stmt), assert);
                                        removedParentsDictionary.Remove(assert);
                                        Console.WriteLine("Inserted");
                                        break;
                                    }
                                }
                            }
                            else {
                                //not sure why it gets here but it does...
                                if (!blockStmt.Body.Contains(assert)) {
                                    //find the right position to add at
//                                    for (int i = 0; i <= blockStmt.Body.Count; i++) {
//                                        if (blockStmt.Body[i] != null) {
//                                            if (blockStmt.Body[i].Tok.pos > assert.Tok.pos) {
//                                                blockStmt.Body.Insert(i, assert);
//                                            }
//                                        }
//                                    }
//                                        blockStmt.Body.Add(assert);
                                    foreach (Statement stmt in blockStmt.Body) {
                                        if (stmt.Tok.pos > assert.Tok.pos) {
                                            blockStmt.Body.Insert(blockStmt.Body.IndexOf(stmt), assert);
                                            break;
                                        }
                                    }
                                }
                                else {
                                    Console.WriteLine("Body already contains this");
                                }
                            }
                        }
                    }
                    else if (statement is MatchStmt) {
                        MatchStmt maxMatchStmt = (MatchStmt) statement;
                        foreach (MatchCaseStmt stmt in maxMatchStmt.Cases) {
                            errorMatches.Add(stmt);
                            foreach (AssertStmt assert in asserts[statement]) {
                                if (removedCaseStmts.ContainsKey(assert)) {
                                    stmt.Body.Add(assert);
                                    removedCaseStmts.Remove(assert);
                                    break;
                                }
                                else {
                                    if (!stmt.Body.Contains(assert)) {
                                        stmt.Body.Add(assert);
                                    }
                                }
                            }
                        }
                    }
                    else {
                        Console.WriteLine("ERROR: the parent not a block statement");
                    }
                }
//                foreach (AssertStmt assert in asserts[maxBlock]) {
//                    
//                    if (token.line + 1 == assert.Tok.line) {
//                        assertsToKeep.Add(assert);
//                        Console.WriteLine("Adding " + token.line + " to " + assert.Tok.line);
//                        return;
//                    }
//                }
//                Console.WriteLine("Failed to reinsert a token in {0}: ({1},{2})", program.FullName, token.line,
//                    token.col);
            }
        }
        
        private Program CloneProgram(Program program)
        {
            var cloner = new Cloner();
            var moduleDecl = new LiteralModuleDecl(cloner.CloneModuleDefinition(program.DefaultModuleDef, program.Name), null);
            return new Program(program.FullName, moduleDecl, program.BuiltIns);
        }

        public bool IsProgramValid()
        {
            Contract.Requires(program != null);
            string programId = "main_program_id";
            Bpl.PipelineStatistics stats = new Bpl.PipelineStatistics();

            var translator = new Translator();
            Program programCopy = CloneProgram(program);

            var resolver = new Resolver(programCopy);
            try
            {
                resolver.ResolveProgram(programCopy);
            }
            catch
            {
                Console.WriteLine("Failed to resolve program");
                return false;
            }

            Bpl.Program boogieProgram;
            try {
                boogieProgram = translator.Translate(programCopy);
            }
            catch {
                Console.WriteLine("Program " + programCopy.FullName + "failed to translate.");
                return false;
            }

           

            var bplFileName = "bplFile";
            Bpl.LinearTypeChecker ltc;
            Bpl.MoverTypeChecker mtc;

            var oc = Bpl.ExecutionEngine.ResolveAndTypecheck(boogieProgram, bplFileName, out ltc, out mtc);
            switch (oc) {
                case Bpl.PipelineOutcome.ResolutionError:
                    return false;
                case Bpl.PipelineOutcome.TypeCheckingError:
                    return false;
                case Bpl.PipelineOutcome.ResolvedAndTypeChecked:
                    Bpl.ExecutionEngine.EliminateDeadVariables(boogieProgram);
                    Bpl.ExecutionEngine.CollectModSets(boogieProgram);
                    Bpl.ExecutionEngine.CoalesceBlocks(boogieProgram);
                    Bpl.ExecutionEngine.Inline(boogieProgram);

                    Bpl.ErrorReporterDelegate er = BoogieErrorInformation;
                    try {
                        oc = Bpl.ExecutionEngine.InferAndVerify(boogieProgram, stats, programId, er);
                    }
                    catch {
                        Console.WriteLine("Verification caused exception");
                        return false;
                    }
                    var allOk = stats.ErrorCount == 0 && stats.InconclusiveCount == 0 && stats.TimeoutCount == 0 && stats.OutOfMemoryCount == 0;
                    if (!allOk) {
                        //The program failed to verify - we must now find the allAsserts from the list of tokens we got.
                        Console.WriteLine("Verification failed. Errors: ");
                        foreach (AssertStmt assert in assertsToKeep) {
                            Console.WriteLine("Error was found at " + assert.Tok.line);
                        }
                    }
                    switch (oc) {
                        case Bpl.PipelineOutcome.VerificationCompleted:
                            if (allOk) Console.WriteLine("Verification successful");
                            return allOk;

                        case Bpl.PipelineOutcome.Done:
                            if (allOk) Console.WriteLine("Verification successful");
                            return allOk;
                        default:
                            return false;
                    }
                case Bpl.PipelineOutcome.FatalError:
                    return false;
                case Bpl.PipelineOutcome.VerificationCompleted:
                    return true;
                default:
                    return false;
            }
        }

        #endregion
    }
}